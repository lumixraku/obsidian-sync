https://go7hic.github.io/A-Philosophy-of-Software-Design/#/

基本上在讲 “写可维护的代码”

## Chapter 2

造成软件难以维护的原因是复杂性，尤其是难以遇见的复杂性。
这是因为人们的认知负荷导致。


## Chapter 3 (Strategic vs. Tactical Programming)
如果您想要一个好的设计，则必须采取更具战略性的方法。我觉得这里的战略性意思就是指的目标和眼光，大意是应该看的更长远。

好的设计不是没有代价的， 需要你持续不断的投入。

## Chapter 4 模块应该是深邃的

关于模块的划分
- **理想状态**：模块完全独立，无需了解其他模块即可工作。
- **现实挑战**：模块必须通过函数或方法调用协同工作，形成依赖关系。

一个 shallow 模块的例子
此方法会使情况变得更糟，而不是更好
```
private void addNullValueForAttribute(String attribute) { 
    data.put(attribute, null); 
}
```

后面仍然是用 Java 的文件读取来举例，仍然是一个违背深模块的例子
文中提到在 Java 中读取文件需要用到三个类（使用 Buffer 的话，并且大部分人在读取文件的时候都需要用 Buffer 机制）
但是在得到文件内容后， 后续的所有操作都是在 objectStream 上进行， fileStream 和 bufferedStream 就仅仅在这一刻用， 后续都没有用到。 这是不好的设计。
```

FileInputStream fileStream = new FileInputStream(fileName); 

BufferedInputStream bufferedStream = new BufferedInputStream(fileStream);

ObjectInputStream objectStream = new ObjectInputStream(bufferedStream);
```

作者认为好的例子是像 Unix 中读取文件接口设计
```

int open(const char* path, int flags, mode_t permissions);

ssize_t read(int fd, void* buffer, size_t count);
```



## Chapter 5 信息的隐藏和泄露

一个功能， 通过太多的类去实现瓦格纳我那个造成信息的泄露。
例如一个 HTTP 请求通过两个类实现， 一个讲网络连接的请求读取为字符串，另一个做字符串解析。这两个类都需要了解 HTTP 请求的大多数结构，并且解析代码在两个类中都是重复的。
**由于这些类共享大量信息，因此最好将它们合并为一个同时处理请求读取和解析的类。**


通常可以通过使类稍大一些来改善信息隐藏。这样做的一个原因是将与特定功能相关的所有代码（例如，解析 HTTP 请求）组合在一起。

一个典型的容易导致信息泄露的例子， 不仅暴露了这个类的内部数据，还有可能导致数据被外部修改。
```
public Map<String, String> getParams() {
    return this.params;
}
```

好的设计应该是下面这样
```

public String getParameter(String name) { ... } 

public int getIntParameter(String name) { ... }

```


## Chapter 6  通用模块应该非常深入

不推荐示范
作者表示这种方法在用户界面和文本类之间造成了信息泄漏（This approach created information leakage between the user interface and the text class.）
```
void deleteSelection(Selection selection);
```

推荐设计
```
void insert(Position position, String newText); 

void delete(Position start, Position end);
```


通用接口比专用接口具有许多优点。它们往往更简单，使用的方法更少。使模块具有某种通用性是降低整体系统复杂性的最佳方法之一


## Chapter 7 Different Layer, Different Abstraction
当相邻的层具有相似的抽象时，问题通常以传递方法的形式表现出来。

传递方法 (Pass-through methods) 是一种不执行任何操作的方法，只是将其参数传递给另一个方法，通常使用与直通方法相同的 API。这通常表示各类之间没有明确的职责划分。

它使得类变得浅薄， 并且在没有增加功能的情况下使得接口变得更多更复杂。它的存在表明类之间的责任划分存在混淆

下面图 a 就是错误用法， b c d 是对应的解法
![[Pasted image 20240717171500.png]]

变量传递
传递变量增加了复杂性，因为它们强制所有中间方法知道它们的存在， 并且修改参数时也很麻烦。

下面 a 是错误用法， b c d 是问题解决方案
方案 b 就是创建一个新对象 shared object， 把所有需要层层传递的对象都放在 shared object 中。
方案 c 是用全局对象来保存要传递的对象。
方案 d 是用上下文来保存要传递的对象。这是作者推荐的方案。

![[Pasted image 20240717171959.png]]

## Chapter 8 Pull Complexity Downwards

模块具有简单的接口比简单的实现更为重要。
尽量不要配置参数。

## Chapter 9 Better Together Or Better Apart?

代码逻辑相关就合并， 不相关就分开。下面是代码相关的一些表现
- 它们共享信息
- 它们一起使用
- 它们概念上重叠
- 不看任何一个就无法理解

Chapter 5  中关于 HTTP 的例子就是典型的信息共享。两个方法都需要对 HTTP 格式有了解

Chapter 4 中 Java 文件读取是一个应当一起使用的例子。把它们汇聚在一起能减少接口。

举例：
编辑器的撤销能力应该独立成一个类而不是作为文本类的一部份。

关于 method 拆分
避免出现 d 的情况， 这会导致 shallow method
![[Pasted image 20240717193947.png]]

## Chapter 10 Define Errors Out Of Existence

"define errors out of existence" 翻译为中文是“定义错误使之不存在” 

The best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: define errors out of existence. 
消除异常处理复杂性的最佳方式是通过定义你的API，使得没有异常需要处理：定义错误使之不存在。

掩盖异常
用 NFS 文件服务器举例， NFS 文件服务器应该不要抛出错误而是 hang 住。